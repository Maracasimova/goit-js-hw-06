1. Сначала мы находим элемент ul#categories и получаем все его дочерние элементы с классом item. 
Затем мы выводим количество элементов li.item в списке ul#categories.

Для каждого элемента li.item мы находим заголовок элемента h2 и количество вложенных элементов li внутри него. 
Затем мы выводим текст заголовка и количество элементов в категории в консоль.

2. Сначала мы находим элемент ul#ingredients. 
Затем мы используем метод map() для создания массива новых элементов li на основе массива строк ingredients. 
Для каждого ингредиента мы создаем новый элемент li, добавляем его текстовое содержимое и класс item.

Затем мы используем метод append() для вставки всех новых элементов li одним вызовом в список ul#ingredients. 
Мы передаем оператор расширения spread operator (троеточие перед массивом) в качестве аргумента для метода append(), 
чтобы добавить каждый элемент массива ingredientsItems в качестве отдельного аргумента.

3. Сначала мы находим элемент списка ul.gallery.
Затем мы используем метод map() для создания массива новых элементов li, каждый из которых содержит вложенный элемент img.
Мы используем деструктуризацию объектов для извлечения свойств url и alt из каждого объекта в массиве images.

Для каждого объекта в массиве images мы создаем строку шаблона, в которой мы вставляем значения url и alt в качестве атрибутов для элемента img.
Мы также добавляем классы gallery__item и gallery__image для соответствующих элементов li и img.

Затем мы используем метод insertAdjacentHTML() для вставки всех новых элементов li в список ul.gallery одним вызовом.
Мы передаем строку, содержащую все новые элементы li, в качестве аргумента для метода insertAdjacentHTML().

4. В этом коде мы находим элементы кнопок и спана, используя метод querySelector.
// Далее мы создаем переменную value, которая будет использоваться для хранения текущего значения счетчика.

// Затем мы добавляем слушатели событий click для кнопок увеличения и уменьшения счетчика.
// Каждый раз, когда пользователь нажимает на одну из кнопок, мы увеличиваем или уменьшаем переменную value на 1,
//     а затем обновляем текстовое содержимое спана с помощью свойства textContent.

5. Сначала мы находим инпут и спан в DOM с помощью метода querySelector.
// Затем мы добавляем слушатель события 'input' на инпут.
// Каждый раз, когда пользователь вводит текст в инпут,
//     мы обновляем содержимое спана текстом из инпута, если инпут не пустой, или строкой 'Anonymous', если инпут пустой.

6. В этом решении мы добавляем слушатель события blur на элемент inputRef.
// При срабатывании события, мы проверяем количество символов в inputRef, используя свойство value.length, и
// сравниваем его с необходимым количеством, хранящимся в атрибуте data - length.
// Затем мы добавляем или удаляем соответствующие CSS - классы, чтобы изменить цвет границы элемента inputRef.

7. В этом решении мы находим элементы на странице с помощью метода document.querySelector().
// Затем добавляем слушатель события input на ползунок #font - size - control.
// Когда значение ползунка изменяется, мы обновляем размер шрифта элемента #text, устанавливая значение его инлайн - стиля fontSize.
  Обратите внимание, что значение fontSizeControl.value является строкой, поэтому мы преобразуем его в число, добавив px в конец.

8. Мы начинаем с выбора формы с помощью метода document.querySelector.
 Затем мы добавляем обработчик события submit на форму с помощью метода addEventListener.

 Когда форма отправляется, сначала мы вызываем метод preventDefault() на объекте события, чтобы предотвратить перезагрузку страницы.

 Затем мы используем деструктуризацию объекта, чтобы получить доступ к элементам формы по их имени.
 Мы проверяем, заполнены ли оба поля, и если нет, выводим сообщение об ошибке и выходим из функции.

 Если оба поля заполнены, мы создаем объект formData, используя значения полей в качестве значений свойств объекта.
 Затем мы выводим объект formData в консоль и очищаем значения полей формы, вызывая метод reset() на форме.

9. Этот скрипт добавляет слушатель событий на кнопку, который вызывает функцию changeColor при клике.
Функция changeColor генерирует случайный цвет и устанавливает его как цвет фона body, а также выводит его значение в span.
 Функция getRandomHexColor генерирует случайный шестнадцатеричный цвет в формате #RRGGBB.

10. Обработчик нажатия на кнопку создания создает массив из элементов div, задает им ширину,
  высоту и цвет фона, и затем добавляет все элементы массива в контейнер div#boxes.
  Обработчик нажатия на кнопку удаления очищает содержимое контейнера div#boxes.
 Функция getRandomHexColor возвращает случайный цвет в формате HEX.

